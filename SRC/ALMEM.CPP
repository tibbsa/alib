// 袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴 
// ALMEM.CPP: ALIB; Memory allocation tracking implementation
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴 
// (This is part of my "utility library"- define STANDALONE and it'll use
// nothing that isn't included here)
// 袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴袴 

#include <alib.h>
Set_Alert_File ("ALMEM.CPP<library ALIB>")

// Use MALLOC macro for this!
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// void *Malloc (unsigned size, char *file, unsigned line)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: unsigned size      Size of block to allocate
//            char *file         (Internal use only - filename of alloc)
//            unsigned line      (Internal use only - line # of alloc)
// Return:    Pointer to block of memory
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Allocates a block of memory (size bytes long), adding the pointer to 
// the memory tracking file.
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
void *Malloc (unsigned size, char *file, unsigned line)
{
FILE *fp;
void *ptr;

   Alert (size == 0);

   ptr = (void *)malloc (size);
   if (!ptr)
   {
      alib.log.Put ("!Memory allocation error");
      return (NULL);
   }

   if (!MemTrkAddPtr (ptr, size, file, line))
   {
      free (ptr);
      return (NULL);
   }
   
#ifdef DEBUG
   alib.log.Put ("MAlloc: %p (%ub@%u/%s)", ptr, size, line, file);
#endif

   return (ptr);
}

// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// int MemTrkAddPtr (void *ptr, char *file, unsigned line)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: void *ptr          Pointer to add to "memtrack" file.
//            int size           Size of block allocated
//            char *file         (Internal use only - filename of alloc)
//            unsigned line      (Internal use only - line # of alloc)
// Return:    False if there is an error
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Adds ptr to the memory database file...
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
int MemTrkAddPtr (void *ptr, int size, char *file, unsigned line)
{
#ifdef DEBUG
FILE *fp;
memtrk_entry m;
   Alert (ptr == NULL);
   Alert (file == NULL);
   Alert (*file == '\0');
   Alert (line == 0);

   m.ptr = ptr;
   m.size = size;
   strcpy (m.file, file);
   m.line = line;

   fp = fopen ("MEMTRK.DBG", "ab");

   if (!fp)
   {
      alib.log.Put ("MError updating MEMTRK.DBG file!");
      return (False);
   }
   fwrite (&m, 1, sizeof m, fp);
   fclose (fp);

#endif
   return 1;
}

// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// void MemTrkRemovePtr (void *ptr);
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: void *ptr          Pointer to remove from "memtrack" file.
// Return:    
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Removes ptr from the database
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
void MemTrkRemovePtr (void *ptr)
{
#ifdef DEBUG
FILE *fp;
FILE *op;
memtrk_entry m;

   fp = fopen ("MEMTRK.DBG", "rb");
   if (!fp)
   {
#ifdef DEBUG
      alib.log.Put ("MError reading MEMTRK.DBG file!");
#endif
      return;
   }
   op = fopen ("$$$.mtb", "wb");
   if (!op)
   {
      fclose (fp);
#ifdef DEBUG
      alib.log.Put ("MError writing temporary tracking file!");
#endif
      return;
   }


   void *lastptr=NULL;
   
   while (!feof(fp))
   {
      fread (&m, 1, sizeof m, fp);
      if (lastptr==m.ptr)
         continue;
      
      lastptr=m.ptr;
      if (m.ptr == ptr)
         continue;
      else
         fwrite (&m, 1, sizeof m, op);
   }
   fclose (op);
   fclose (fp);
   unlink ("MEMTRK.DBG");
   rename ("$$$.mtb", "MEMTRK.DBG");
#endif
}

// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// void Free (void *ptr, char *file, unsigned line)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: void *ptr          Pointer to free
// Return:    
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Frees pointer "ptr"
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
void Free (void *ptr, char *file, unsigned line)
{
   if (!ptr)
      return;

   if (!IsValid(ptr))
   {
      /* Just to keep Carey happy.. */
      alib.log.Put ("!Freeing unallocated pointer %p", ptr);
      alib.log.Put ("!  Line %u, file %s", line, file);
   }


   /* Remove it from the list of pointers. */
#ifdef DEBUG
   alib.log.Put ("MFreeing %p@%u/%s", ptr, line, file);
#endif
   MemTrkRemovePtr (ptr);
   ptr = NULL;
   free (ptr);
}

// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// int IsValid (void *ptr)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: void *ptr          Pointer to check for in memtrack file
// Return:    True if pointer is in memtrack file, otherwise False
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Checks to see if pointer "ptr" is (still) in the memtrack file.  (e.g.
// it hasn't been free'd)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
int IsValid (void *ptr)
{
#ifdef DEBUG
FILE *fp;
memtrk_entry m;

   fp = fopen ("MEMTRK.DBG", "rb");
   if (!fp)
   {
      alib.log.Put ("MError reading MEMTRK.DBG file!");
      return (False);
   }
   while (!feof(fp))
   {
      fread (&m, 1, sizeof m, fp);
      if (m.ptr == ptr)
      {
         fclose (fp);
         return 1;
      }
   }

   alib.log.Put ("MPointer %p is NOT valid");
   fclose (fp);
#endif
   return 0;
}

// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// int MemTrkDiagnostics (void)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: 
// Return:    True if the memtrack file is not blank, False if it is
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Sees if everything has been freed
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
int MemTrkDiagnostics (void)
{
#ifdef DEBUG
FILE *fp;

   fp = fopen ("MEMTRK.DBG", "rb");
   if (!fp)
   {
      alib.log.Put ("MError reading MEMTRK.DBG file!");
      return 0;
   }

   if (filelength(fileno(fp)) != 0L)
   {
      fclose (fp);
      return 1;
   }
   else
   {
      fclose (fp);
      return 0;
   }
#else
   return 1;
#endif
}

// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// void MemTrkDump (void)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: 
// Return:    
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Dumps the contents of the memory tracking file to the screen
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
void MemTrkDump (void)
{
#ifdef DEBUG
FILE *fp;
memtrk_entry m;

   if (!MemTrkDiagnostics())
      return;

   fp = fopen ("MEMTRK.DBG", "rb");
   if (!fp)
   {
      alib.log.Put ("MError reading MEMTRK.DBG file!");
      return;
   }
   printf ("The following pointers were NOT freed:\n\n");

   alib.log.Put ("MPointers not freed:");

void *lastptr=NULL;

   while (!feof(fp))
   {
      fread (&m, 1, sizeof m, fp);
      if (lastptr==m.ptr)
         continue;
      lastptr=m.ptr;
      printf ("%p\tSize=%-.5u\tFile: %s, Line: %u\n", m.ptr, m.size, m.file, m.line);
      alib.log.Put ("M   %p\tSize=%-.5u\tFile: %s, Line: %u\n", m.ptr, m.size, m.file, m.line);
   }

   fclose (fp);
#endif
}

// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// void MemTrkCleanup (void)
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Arguments: 
// Return:    
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
// Deallocates any memory which is currently allocated 
// 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
void MemTrkCleanup (void)
{
#ifdef DEBUG
FILE *fp;
memtrk_entry m;

   if (!MemTrkDiagnostics())
      return;

   fp = fopen ("MEMTRK.DBG", "rb");
   if (!fp)
   {
      alib.log.Put ("MError reading MEMTRK.DBG file!");
      return;
   }

void *lastptr=NULL;

   alib.log.Put ("MCLEANUP --------------------------------------");

   while (!feof(fp))
   {
      fread (&m, 1, sizeof m, fp);
      if (lastptr==m.ptr)
         continue;
      lastptr=m.ptr;
      FREE (m.ptr);
   }

   alib.log.Put ("MCLEANUP --------------------------------------");
   fclose (fp);
#endif
}
